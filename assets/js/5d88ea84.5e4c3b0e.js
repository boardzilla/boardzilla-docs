"use strict";(self.webpackChunkboardzilla_docs=self.webpackChunkboardzilla_docs||[]).push([[2965],{5882:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>l});var a=s(5893),i=s(1151);const c={sidebar_position:7},r="Adjacency and Grids",t={id:"game/adjacency",title:"Adjacency and Grids",description:"Boardzilla provides a few tools to help determine adjacency or distance between",source:"@site/docs/game/adjacency.md",sourceDirName:"game",slug:"/game/adjacency",permalink:"/game/adjacency",draft:!1,unlisted:!1,editUrl:"https://github.com/boardzilla/boardzilla-docs/tree/main/docs/game/adjacency.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Flow",permalink:"/game/flow"},next:{title:"Customizing the UI",permalink:"/category/customizing-the-ui"}},d={},l=[{value:"Types of grids",id:"types-of-grids",level:2},{value:"Fixed grid",id:"fixed-grid",level:2},{value:"Square grids",id:"square-grids",level:3},{value:"Hex grids",id:"hex-grids",level:3},{value:"Custom adjacency",id:"custom-adjacency",level:3},{value:"Flexible Grid",id:"flexible-grid",level:2},{value:"Extendable Grid",id:"extendable-grid",level:3},{value:"Irregular Shapes",id:"irregular-shapes",level:3}];function o(e){const n={a:"a",admonition:"admonition",code:"code",div:"div",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"adjacency-and-grids",children:"Adjacency and Grids"}),"\n",(0,a.jsx)(n.p,{children:"Boardzilla provides a few tools to help determine adjacency or distance between\ngame elements. This can be complicated since different games might have wildly\ndifferent needs for measuring distance and adjacency. So what is provided in\nBoardzilla is intended to cover a few basic scenarios while affording\nflexibility for a variety of non-traditional concepts of adjacency."}),"\n",(0,a.jsxs)(n.p,{children:["It's also important that we distinguish between the concept of positioning from\nthe perspective of the ",(0,a.jsx)(n.em,{children:"game's rules"})," as opposed to positioning from the\nperspective of its ",(0,a.jsx)(n.em,{children:"appearance"})," on screen. The two are related. If adjacency is\nimportant to the game's rules, keep reading. The relationship between rules and\nappearance will be explained. If however, the positioning is only important from\na visual perspective, refer instead to ",(0,a.jsx)(n.a,{href:"../ui/layout",children:"Layout"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"types-of-grids",children:"Types of grids"}),"\n",(0,a.jsxs)(n.p,{children:["To understand adjacency, we need to talk about the grid on which we're\nplaying. In Boardzilla there are two fundamentally different grid concepts that\ncan be leveraged, ",(0,a.jsx)(n.em,{children:"fixed"})," and ",(0,a.jsx)(n.em,{children:"flexible"}),". Which one we use depends on the type\nof game."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Fixed"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Applies to ",(0,a.jsx)(n.a,{href:"core-concepts#space",children:"Spaces"})]}),"\n",(0,a.jsx)(n.li,{children:"Is usually visible"}),"\n",(0,a.jsx)(n.li,{children:"Does not change size"}),"\n",(0,a.jsx)(n.li,{children:"Useful for chessboards, Catan, etc."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Flexible"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Applies to ",(0,a.jsx)(n.a,{href:"core-concepts#piece",children:"Pieces"})]}),"\n",(0,a.jsx)(n.li,{children:'An "imaginary" grid that can change position and size depending on its contents'}),"\n",(0,a.jsx)(n.li,{children:"Handles irregularly shaped pieces that occupy multiple cells"}),"\n",(0,a.jsx)(n.li,{children:"Useful for tile placement games, dominoes, etc."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"fixed-grid",children:"Fixed grid"}),"\n",(0,a.jsxs)(n.p,{children:["A fixed grid is a grid of ",(0,a.jsx)(n.a,{href:"../api/classes/Space",children:"Spaces"})," that are created when\nwe define our Game. These come in a few flavors:\n",(0,a.jsx)(n.a,{href:"../api/classes/SquareGrid",children:"SquareGrid"}),", ",(0,a.jsx)(n.a,{href:"../api/classes/HexGrid",children:"HexGrid"})," and\n",(0,a.jsx)(n.a,{href:"../api/classes/ConnectedSpaceMap",children:"ConnectedSpaceMap"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"square-grids",children:"Square grids"}),"\n",(0,a.jsx)(n.p,{children:"For a typical chessboard, we would say:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  import { SquareGrid } from '@boardzilla/core';\n\n  game.create(SquareGrid, 'chessBoard', { rows: 8, columns: 8});\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["This creates 64 Spaces and automitically sets ",(0,a.jsx)(n.code,{children:"row"})," and ",(0,a.jsx)(n.code,{children:"column"})," properties on\neach. We can query these like any other property, e.g."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  // the top-left corner\n  const corner = $.chessBoard.first(Space, { row: 1, column: 1 })!;\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess2.svg"})}),"\n",(0,a.jsx)(n.p,{children:"And we can now use adjacency and distance methods on these spaces. For example,\nto get the two spaces directly adjacent to the corner, we can say:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  corner.adjacencies(Space);\n  // or\n  $.chessBoard.allAdjacentTo(corner, Space);\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess3.svg"})}),"\n",(0,a.jsx)(n.p,{children:"We can also measure distance, for example a knight's move is a distance of 3\nspaces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const knight = $.chessBoard.first(Space, { row: 3, column: 2 })!;\n\n  corner.distanceTo(knight); // 3\n  // or\n  $.chessBoard.distanceBetween(corner, knight);\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess4.svg"})}),"\n",(0,a.jsx)(n.p,{children:"We can query for other spaces with a certain distance as well. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  corner.withinDistance(5);\n  // or\n  map.allWithinDistanceOf(corner, 5, Space);\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess5.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["If diagonals need to be treated as adjacent, this can be done by setting\n",(0,a.jsx)(n.a,{href:"../api/classes/SquareGrid#diagonaldistance",children:(0,a.jsx)(n.code,{children:"diagonalDistance"})})," to some\nnumber. The number will be the distance for diagonal moves, e.g.:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  game.create(SquareGrid, 'chessBoard2', { rows: 8, columns: 8, diagonalDistance: 1.5 });\n"})}),"\n",(0,a.jsx)(n.p,{children:"This affects both adjacency:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const corner = $.chessBoard2.first(Space, { row: 1, column: 1 })!;\n\n  corner.adjacencies(); // now 3 Spaces\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess7.svg"})}),"\n",(0,a.jsx)(n.p,{children:"and distance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const corner = $.chessBoard2.first(Space, { row: 1, column: 1 })!;\n  const knight = $.chessBoard2.first(Space, { row: 3, column: 2 })!;\n\n  corner.distanceTo(knight); // 2.5\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess6.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["When we apply a visual ",(0,a.jsx)(n.a,{href:"../ui/layout",children:"layout"})," to spaces that have been created\nwith rows and columns, the layout API automatically uses that row/column\ninformation to layout the space. Practically speaking that means it is usually\nunnecessary to define ",(0,a.jsx)(n.code,{children:"rows"})," and ",(0,a.jsx)(n.code,{children:"columns"})," for such a layout as the default will\nfollow the grid structure."]}),"\n",(0,a.jsx)(n.p,{children:"In rare cases when unpositioned items are put into the same layout as positioned\ngrid items, the unpositioned ones will be fit around the grid."}),"\n",(0,a.jsx)(n.h3,{id:"hex-grids",children:"Hex grids"}),"\n",(0,a.jsxs)(n.p,{children:["In the case of hex grids, specify the grid ",(0,a.jsx)(n.code,{children:"style"}),". Essentially what this does\nis create a grid with non-orthogonal rows and columns where adjacency applies in\n6 directions, rather than 4 or 8. There are a few different shapes and row,\ncolumn configurations to choose from."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  import { HexGrid } from '@boardzilla/core';\n\n  game.create(HexGrid, 'diamondBoard' { rows: 3, columns: 3 );\n  game.create(HexGrid, 'hexBoard' { rows: 5, columns: 5, shape: 'hex' );\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"100%"},children:(0,a.jsx)(n.img,{src:"/img/hex.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["Adjacency now applies in 6 directions, although the adjacent row, column pairs\nwill depend on which ",(0,a.jsx)(n.code,{children:"axes"})," was used."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  game.create(HexGrid, 'hexBoard', { rows: 3, columns: 3, shape: 'hex' );\n\n  const middle = $.hexBoard.first(Space, { row: 2, column: 2 })!;\n\n  middle.adjacencies(Space); // 6 such Spaces\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/hex2.svg"})}),"\n",(0,a.jsx)(n.p,{children:"Distance calculations apply in the same way as square grids. However, there are\nnever special diagonals in hex grids, and all 6 directions are treated equally."}),"\n",(0,a.jsx)(n.admonition,{title:"hex shapes",type:"tip",children:(0,a.jsxs)(n.p,{children:["By default, this creates spaces at every row and column starting from 1,1 to the\n",(0,a.jsx)(n.code,{children:"rows"})," and ",(0,a.jsx)(n.code,{children:"columns"})," specified. This means that the shape we get by default is\nrhomboid. If some other shape is desired, set ",(0,a.jsx)(n.code,{children:"shape"})," to 'hex' or 'square'"]})}),"\n",(0,a.jsxs)(n.p,{children:["These create adjacencies for use by the rules of the game. And visually it\ncreates a default grid that matches the style and shape of grid specified. These\ncan have ",(0,a.jsx)(n.a,{href:"../ui/layout",children:"layouts"})," applied like other Spaces, however, these grids\nonly have a single layout for their Spaces. Rather than calling ",(0,a.jsx)(n.code,{children:"layout"})," to\nlayer on more layouts, you modify the base layout by calling\n",(0,a.jsx)(n.a,{href:"../api/classes/AdjacencySpace#configurelayout",children:(0,a.jsx)(n.code,{children:"configureLayout"})}),'. See the\n"hex" preset in ',(0,a.jsx)(n.a,{href:"../ui/layout-sandbox",children:"the layout sandbox"})," as an example."]}),"\n",(0,a.jsx)(n.h3,{id:"custom-adjacency",children:"Custom adjacency"}),"\n",(0,a.jsxs)(n.p,{children:["For all other styles of adjacency, use the base class\n",(0,a.jsx)(n.a,{href:"../api/classes/ConnectedSpaceMap",children:"ConnectedSpaceMap"}),". Using this we can add\nSpaces and connect them in whatever adjacency configuration is needed by calling\n",(0,a.jsx)(n.a,{href:"../api/classes/ConnectedSpaceMap#connect",children:"connect"}),". These can have custom\ndistances applied to them to use for distance calculations. This is actually\njust a ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",children:"directed\ngraph"}),". There are\ntoo many possibilities to describe fully. A simple example would be creating a\ngraph of spaces with travel distances:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const map = game.create(ConnectedSpaceMap, 'map');\n\n  const space1 = map.create(Space, 'space1');\n  const space2 = map.create(Space, 'space2');\n  const space3 = map.create(Space, 'space3');\n\n  map.connectTo(space1, space2, 2);\n  map.connectTo(space2, space3, 3);\n  map.connectTo(space1, space3, 6);\n\n  map.distanceBetween(space1, space3); // equals 5 using a path thru space2\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/connect-to.svg"})}),"\n",(0,a.jsxs)(n.p,{children:['Note that any connection is considered "adjacent" but the distance provided as\nthe 2nd argument is used in any queries or methods that measure distance, e.g.\n',(0,a.jsx)(n.a,{href:"../api/classes/ConnectedSpaceMap#distancebetween",children:(0,a.jsx)(n.code,{children:"distanceBetween"})})," or\n",(0,a.jsx)(n.a,{href:"../api/classes/ConnectedSpaceMap#allwithindistanceof",children:(0,a.jsx)(n.code,{children:"allWithinDistanceOf"})}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"flexible-grid",children:"Flexible Grid"}),"\n",(0,a.jsx)(n.p,{children:"The flexible grid is for placing Pieces on a space where the grid is not\nnecessarily part of the board, or even a physical, visible thing. For example,\nwhen playing dominoes, you do not usually have an actual visible grid on the\ntable, but an imaginary one is created as tiles are placed, which becomes the\nbasis for determining if a domino is in a valid position based on adjacency to\nthe other dominoes."}),"\n",(0,a.jsxs)(n.p,{children:["The class ",(0,a.jsx)(n.a,{href:"../api/classes/PieceGrid",children:(0,a.jsx)(n.code,{children:"PieceGrid"})})," is the basis for all flexible\ngrids. It is a grid that only directly contains Pieces and provides some other\nspecial behaviour for the pieces placed in it. Any pieces in the PieceGrid must\nhave a ",(0,a.jsx)(n.code,{children:"row"})," and ",(0,a.jsx)(n.code,{children:"column"})," assigned to them, either by the game or the\nplayer. Players normally place pieces onto the grid using the special\n",(0,a.jsx)(n.a,{href:"../api/classes/Action#placepiece",children:(0,a.jsx)(n.code,{children:"placePiece"})}),". choice, which is specifically\ndesigned for this, and sets the ",(0,a.jsx)(n.code,{children:"row"})," and ",(0,a.jsx)(n.code,{children:"column"})," (and optionally ",(0,a.jsx)(n.code,{children:"rotation"})," as\nwell)."]}),"\n",(0,a.jsx)(n.p,{children:"Once a piece is placed on the PieceGrid, you can use the adjacency methods of\nthe class to determine what pieces are adjacent to each other. This is just like\nthe fixed grid, except for two very important characteristics:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The grid can ",(0,a.jsx)(n.strong,{children:"extend"})]}),"\n",(0,a.jsxs)(n.li,{children:["Pieces can have ",(0,a.jsx)(n.strong,{children:"irregular"})," shapes"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"extendable-grid",children:"Extendable Grid"}),"\n",(0,a.jsxs)(n.p,{children:["When players choose to place dominoes, there is no limit to the imaginary grid\non the table. Everyone playing the game has probably had the experience of\ngetting up to the edge of the table, and needing to slide the entire structure\nto make room. The imaginary grid of a PieceGrid is likewise essentially\ninfinite! You can set the ",(0,a.jsx)(n.code,{children:"rows"})," and ",(0,a.jsx)(n.code,{children:"columns"})," properties of a PieceGrid just\nlike the SquareGrid and HexGrid, but it will automatically grow beyond the\ninitial size as players place pieces. This behaviour can be disabled if you\nactually want a limited playing field by setting ",(0,a.jsx)(n.code,{children:"extendableGrid"})," to ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"irregular-shapes",children:"Irregular Shapes"}),"\n",(0,a.jsxs)(n.p,{children:["Pieces can be given irregular shapes by calling\n",(0,a.jsx)(n.a,{href:"../api/classes/Piece#setshape",children:(0,a.jsx)(n.code,{children:"setShape"})}),". The shapes are represented as\nstrings with non-space characters to show filled in areas of the shape, and\nspaces to show gaps. E.g. the squiggle tetris piece might look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"   tetrisPiece.setShape(\n     'XX ',\n     ' XX'\n   );\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The shape of a piece does not normally matter much, expect when placed on a\n",(0,a.jsx)(n.code,{children:"PieceGrid"}),". When on a ",(0,a.jsx)(n.code,{children:"PieceGrid"}),", the piece will fill the appropriate number\nof rows and columns as its size increases. The exact shape determines what is\nadjacent to what, or what overlaps what and is therefore invalid."]}),"\n",(0,a.jsx)(n.p,{children:"The cells can also be labelled. This is useful when we want to query exactly\nwhich part of a piece is adjacent to another piece. For example in dominoes, we\nneed to know if the adjacent dominoes have matching numbers. We can do so with\nlabels, e.g.:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  domino12.setShape(\n    '12'\n  );\n\n  domino23.setShape(\n    '23'\n  );\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Now if we want to check the adjacency of ",(0,a.jsx)(n.code,{children:"domino12"})," and ",(0,a.jsx)(n.code,{children:"domino23"})," if they were\nplaced side-by-side, we can place them onto a ",(0,a.jsx)(n.code,{children:"PieceGrid"})," and then use the\n",(0,a.jsx)(n.a,{href:"../api/classes/PieceGrid#adjacenciesbycell",children:(0,a.jsx)(n.code,{children:"adjacenciesByCell"})})," method of the\ngrid."]}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/dominoes.svg"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  dominoGrid.adjacenciesByCell(domino12, domino23);\n  // will return:\n  [\n    {\n      piece: domino23,\n      from: '2',\n      to: '2'\n    }\n  ]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Like with a ",(0,a.jsx)(n.a,{href:"../api/classes/SquareGrid",children:"SquareGrid"}),", we can also have diagonal\nadjacent, by setting\n",(0,a.jsx)(n.a,{href:"../api/classes/PieceGrid#diagonaladjacency",children:(0,a.jsx)(n.code,{children:"diagonalAdjacency"})}),", the\n",(0,a.jsx)(n.code,{children:"adjacenciesByCell"})," method will also return cells that touch only by a corner."]}),"\n",(0,a.jsx)(n.p,{children:"We can further add labels to the edges themselves for games where the tiles have\ndistinctive edges that need be adjacent to other types of edges. Edge labels can\nbe added to each of the 4 cardinal directions of each cell. Here's an example of\n2 tiles from a game with tiles that go together to build a countryside."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"   bridge.setShape(\n     'AB',\n     'C '\n   );\n   bridge.setEdges({\n     A: {\n       up: 'road',\n       left: 'river',\n     },\n     B: {\n       right: 'river',\n     },\n     C: {\n       down: 'road',\n     },\n   });\n\n   // this is a simple one-celled shape, so we don't need cell labels\n   roadTurn.setEdges({\n     up: 'road',\n     right: 'road',\n   });\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If these were placed together onto a PieceGrid named ",(0,a.jsx)(n.code,{children:"countryGrid"}),"\ntop-to-bottom, like this:"]}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/tiles.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["We could check if the edges match using the\n",(0,a.jsx)(n.a,{href:"../api/classes/PieceGrid#adjacenciesbyedge",children:(0,a.jsx)(n.code,{children:"adjacenciesByEdge"})})," method of\n",(0,a.jsx)(n.code,{children:"countryGrid"}),", e.g.:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  countryGrid.adjacenciesByEdge(bridge));\n  // will return:\n  [\n    {\n      piece: roadTurn,\n      from: 'river',\n      to: 'river'\n    }\n  ]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"https://github.com/boardzilla/boardzilla-tiles-starter-game",children:"tiles starter\ntemplate"})," has a\nsimple example of using the PieceGrid for tile placement that can be used as a\nstarting point."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>t,a:()=>r});var a=s(7294);const i={},c=a.createContext(i);function r(e){const n=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(c.Provider,{value:n},e.children)}}}]);