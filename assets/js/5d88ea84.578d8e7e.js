"use strict";(self.webpackChunkboardzilla_docs=self.webpackChunkboardzilla_docs||[]).push([[2965],{5882:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>o});var a=s(5893),i=s(1151);const c={sidebar_position:7},t="Adjacency and Grids",r={id:"game/adjacency",title:"Adjacency and Grids",description:"Boardzilla provides a few tools to help determine adjacency or distance between",source:"@site/docs/game/adjacency.md",sourceDirName:"game",slug:"/game/adjacency",permalink:"/game/adjacency",draft:!1,unlisted:!1,editUrl:"https://github.com/boardzilla/boardzilla-docs/tree/main/docs/game/adjacency.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Flow",permalink:"/game/flow"},next:{title:"Customizing the UI",permalink:"/category/customizing-the-ui"}},d={},o=[{value:"Types of grids",id:"types-of-grids",level:2},{value:"Fixed grid",id:"fixed-grid",level:2},{value:"Square grids",id:"square-grids",level:3},{value:"Hex grids",id:"hex-grids",level:3},{value:"Custom adjacency",id:"custom-adjacency",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",div:"div",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"adjacency-and-grids",children:"Adjacency and Grids"}),"\n",(0,a.jsx)(n.p,{children:"Boardzilla provides a few tools to help determine adjacency or distance between\nelements on the Board. This can be complicated since different games might have\nwildly different needs for measuring distance and adjacency. So what is provided\nin Boardzilla is intended to cover a few basic scenarios while affording\nflexibility for a variety of non-traditional concepts of adjacency."}),"\n",(0,a.jsxs)(n.p,{children:["It's also important that we distinguish between the concept of positioning from\nthe perspective of the ",(0,a.jsx)(n.em,{children:"game's rules"})," as opposed to positioning from the\nperspective of its ",(0,a.jsx)(n.em,{children:"appearance"})," on screen. The two are related. If adjacency is\nimportant to the game's rules, keep reading. The relationship between rules and\nappearance will be explained. If however, the positioning is only important from\na visual perspective, refer instead to ",(0,a.jsx)(n.a,{href:"../ui/layout",children:"Layout"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"types-of-grids",children:"Types of grids"}),"\n",(0,a.jsxs)(n.p,{children:["To understand adjacency, we need to talk about the grid on which we're\nplaying. In Boardzilla there are two fundamentally different grid concepts that\ncan be leveraged, ",(0,a.jsx)(n.em,{children:"fixed"})," and ",(0,a.jsx)(n.em,{children:"flexible"}),". Which one we use depends on the type\nof game."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Fixed"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Applies to ",(0,a.jsx)(n.a,{href:"core-concepts#space",children:"Spaces"})]}),"\n",(0,a.jsx)(n.li,{children:"Is usually visible"}),"\n",(0,a.jsx)(n.li,{children:"Does not change once set"}),"\n",(0,a.jsx)(n.li,{children:"Useful for chessboards, Catan, etc."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Flexible"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Applies to ",(0,a.jsx)(n.a,{href:"core-concepts#piece",children:"Pieces"})]}),"\n",(0,a.jsx)(n.li,{children:'An "imaginary" grid that can change position and size depending on its contents'}),"\n",(0,a.jsx)(n.li,{children:"Useful for tile placement games, dominoes, etc."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"fixed-grid",children:"Fixed grid"}),"\n",(0,a.jsxs)(n.p,{children:["A fixed grid is a grid of ",(0,a.jsx)(n.a,{href:"../api/classes/Space",children:"Spaces"})," that are created when\nwe define our Board. These come in a few flavors: square, hex and custom. For\nthe square and hex grids, we start with the\n",(0,a.jsx)(n.a,{href:"../api/classes/Space#creategrid",children:(0,a.jsx)(n.code,{children:"createGrid"})})," method."]}),"\n",(0,a.jsx)(n.h3,{id:"square-grids",children:"Square grids"}),"\n",(0,a.jsx)(n.p,{children:"For a typical chessboard, we would say:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  board.createGrid({ rows: 8, columns: 8}, Space, 'chess-square');\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["This creates 64 Spaces and automitically sets ",(0,a.jsx)(n.code,{children:"row"})," and ",(0,a.jsx)(n.code,{children:"column"})," properties on\neach. We can query these like any other property, e.g."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  // the top-left corner\n  const corner = board.first(Space, { row: 1, column: 1 })!;\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess2.svg"})}),"\n",(0,a.jsx)(n.p,{children:"And we can now use adjacency and distance methods on these spaces. For example,\nto get the two spaces directly adjacent to the corner, we can say:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  corner.adjacencies(Space);\n  // or\n  corner.others(Space, { adjacent: true });\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess3.svg"})}),"\n",(0,a.jsx)(n.p,{children:"We can also measure distance, for example a knight's move is a distance of 3\nspaces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const knight = board.first(Space, { row: 3, column: 2 })!;\n\n  corner.distanceTo(knight); // 3\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess4.svg"})}),"\n",(0,a.jsx)(n.p,{children:"We can query for other spaces with a certain distance as well. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  corner.withinDistance(5);\n  // or\n  corner.others(Space, {withinDistance: 3});\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess5.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["If diagonals need to be treated as adjacent, this can be done in the\n",(0,a.jsx)(n.code,{children:"createGrid"})," call. We need to specify the distance for diagonal moves for\ndistance measurements, e.g.:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  board.createGrid({ rows: 8, columns: 8, diagonalDistance: 1.5 }, Space, 'square');\n"})}),"\n",(0,a.jsx)(n.p,{children:"This affects both adjacency:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const corner = board.first(Space, { row: 1, column: 1 })!;\n\n  corner.adjacencies(); // now 3 Spaces\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess7.svg"})}),"\n",(0,a.jsx)(n.p,{children:"and distance:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const corner = board.first(Space, { row: 1, column: 1 })!;\n  const knight = board.first(Space, { row: 3, column: 2 })!;\n\n  corner.distanceTo(knight); // 2.5\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/chess6.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["When we apply a visual ",(0,a.jsx)(n.a,{href:"../ui/layout",children:"layout"})," to spaces that have been created\nwith rows and columns, the layout API automatically uses that row/column\ninformation to layout the space. Practically speaking that means it is usually\nunnecessary to define ",(0,a.jsx)(n.code,{children:"rows"})," and ",(0,a.jsx)(n.code,{children:"columns"})," for such a layout as the default will\nfollow the grid structure."]}),"\n",(0,a.jsx)(n.p,{children:"In rare cases when unpositioned items are put into the same layout as positioned\ngrid items, the unpositioned ones will be fit around the grid."}),"\n",(0,a.jsx)(n.h3,{id:"hex-grids",children:"Hex grids"}),"\n",(0,a.jsxs)(n.p,{children:["In the case of hex grids, specify the grid ",(0,a.jsx)(n.code,{children:"style"}),". Essentially what this does\nis create a grid with non-orthogonal rows and columns where adjacency applies in\n6 directions, rather than 4 or 8. There are two styles depending on the\ndirection of adjacency."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  board.createGrid({ rows: 3, columns: 3, style: 'hex'}, Space, 'cell');\n  board.createGrid({ rows: 3, columns: 3, style: 'hex-inverse'}, Space, 'cell');\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"100%"},children:(0,a.jsx)(n.img,{src:"/img/hex.svg"})}),"\n",(0,a.jsxs)(n.p,{children:["Adjacency now applies in 6 directions, depending on the whether ",(0,a.jsx)(n.code,{children:'"hex"'})," or\n",(0,a.jsx)(n.code,{children:'"hex-inverse"'})," was used."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  board.createGrid({ rows: 3, columns: 3, style: 'hex'}, Space, 'cell');\n\n  const middle = board.first(Space, { row: 2, column: 2 })!;\n\n  middle.adjacencies(Space); // 6 such Spaces\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/hex2.svg"})}),"\n",(0,a.jsx)(n.p,{children:"Distance calculations apply in the same way as square grids. However, there are\nnever special diagonals in hex grids, and all 6 directions are treated equally."}),"\n",(0,a.jsx)(n.admonition,{title:"hex shapes",type:"warning",children:(0,a.jsxs)(n.p,{children:["This creates rows and columns as specified meaning that the shape we initially\nget is rhomboid. If some other shape is desired, one way to acheive that is by\n",(0,a.jsx)(n.a,{href:"../api/classes/GameElement#destroy",children:"destroying"})," the excess Spaces."]})}),"\n",(0,a.jsxs)(n.p,{children:["Remember, these only apply to the ",(0,a.jsx)(n.em,{children:"rules of the game"})," in terms of adjacency and\ndistance. In order to ",(0,a.jsx)(n.em,{children:"visually"})," lay out a hex grid, it is usually necessary to\nalso specify a ",(0,a.jsx)(n.a,{href:"../ui/layout",children:"layout"})," for these spaces with non-orthogonal\nvectors for the ",(0,a.jsx)(n.code,{children:"offsetRow"}),", or ",(0,a.jsx)(n.code,{children:"offsetColumn"}),' or both. See the "hex" preset in\n',(0,a.jsx)(n.a,{href:"../ui/layout-sandbox",children:"the layout sandbox"})," as an example."]}),"\n",(0,a.jsx)(n.h3,{id:"custom-adjacency",children:"Custom adjacency"}),"\n",(0,a.jsxs)(n.p,{children:["For all other styles of adjacency, a\n",(0,a.jsx)(n.a,{href:"../classes/Space#connectto",children:(0,a.jsx)(n.code,{children:"Space#connectTo"})})," method is provided to permit\ncreating custom adjacencies, either on top of one of the grids above, or from\nscratch. These can have custom distances applied to them to use for distance\ncalculations. This is basically an ",(0,a.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",children:"undirected\ngraph"}),". There are\ntoo many possibilities to describe fully. A simple example would be creating a\ngraph of spaces with travel distances:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"  const space1 = board.create(Space, 'space1');\n  const space2 = board.create(Space, 'space2');\n  const space3 = board.create(Space, 'space3');\n\n  space1.connectTo(space2, 2);\n  space2.connectTo(space3, 3);\n  space3.connectTo(space3, 6);\n\n  space1.distanceTo(space3); // equals 5 using a path thru space2\n"})}),"\n",(0,a.jsx)(n.div,{style:{textAlign:"center",width:"30%"},children:(0,a.jsx)(n.img,{src:"/img/connect-to.svg"})}),"\n",(0,a.jsxs)(n.p,{children:['Note that any connection is considered "adjacent" but the distance provided as\nthe 2nd argument is used in any queries or methods that measure distance, e.g.\n',(0,a.jsx)(n.a,{href:"../api/classes/Space#distanceto",children:(0,a.jsx)(n.code,{children:"distanceTo"})})," or\n",(0,a.jsx)(n.a,{href:"../api/classes/Space#withindistance",children:(0,a.jsx)(n.code,{children:"withinDistance"})}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>r,a:()=>t});var a=s(7294);const i={},c=a.createContext(i);function t(e){const n=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(c.Provider,{value:n},e.children)}}}]);